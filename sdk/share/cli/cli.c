/*
 * Copyright (c) 2011 ITE Tech. Inc. All Rights Reserved.
 */
/** @file
 * PAL command line interface functions.
 *
 * @author Jim Tan
 * @version 1.0
 */
#include "cli_cfg.h"
#include "openrtos/FreeRTOS.h"
#include "openrtos/FreeRTOS_CLI.h"
#include <sys/ioctl.h>
#include <pthread.h>
#include <stdio.h>
#include <string.h>
#include "ite/cli.h"

#define CLI_STACK_SIZE 100000

/* Dimensions the buffer into which input characters are placed. */
#define cmdMAX_INPUT_SIZE				200

/*-----------------------------------------------------------*/

static bool cliInited = false;
#ifdef CFG_ENABLE_UART_CLI
bool cliQuit = false;
#else
static bool cliQuit = false;
#endif

static void* CliTask(void* arg)
{
	int8_t cRxedChar, cInputIndex = 0, *pcOutputString;
	static int8_t cInputString[cmdMAX_INPUT_SIZE];
	portBASE_TYPE xReturned;

	LOG_INFO "cli task started\n" LOG_END

		/* Obtain the address of the output buffer.  Note there is no mutual
		exclusion on this buffer as it is assumed only one command console
		interface will be used at any one time. */
		pcOutputString = FreeRTOS_CLIGetOutputBuffer();
#ifdef CFG_ENABLE_UART_CLI
	int i, uart_ret, readPos = 0;
	char cmdbuf[128];
#if defined (CFG_UART0_ENABLE) && defined(CFG_DBG_UART0)
	itpRegisterDevice(ITP_DEVICE_UART0, &itpDeviceUart0);
	ioctl(ITP_DEVICE_UART0, ITP_IOCTL_RESET, (void*)CFG_UART0_BAUDRATE);
#define UART_PORT ITP_DEVICE_UART0
#elif defined (CFG_UART1_ENABLE) && defined(CFG_DBG_UART1)
	itpRegisterDevice(ITP_DEVICE_UART1, &itpDeviceUart1);
	ioctl(ITP_DEVICE_UART1, ITP_IOCTL_RESET, (void*)CFG_UART1_BAUDRATE);
#define UART_PORT ITP_DEVICE_UART1
#elif defined (CFG_UART2_ENABLE) && defined(CFG_DBG_UART2)
	itpRegisterDevice(ITP_DEVICE_UART2, &itpDeviceUart2);
	ioctl(ITP_DEVICE_UART2, ITP_IOCTL_RESET, (void*)CFG_UART2_BAUDRATE);
#define UART_PORT ITP_DEVICE_UART2
#elif defined (CFG_UART3_ENABLE) && defined(CFG_DBG_UART3)
	itpRegisterDevice(ITP_DEVICE_UART3, &itpDeviceUart3);
	ioctl(ITP_DEVICE_UART3, ITP_IOCTL_RESET, (void*)CFG_UART3_BAUDRATE);
#define UART_PORT ITP_DEVICE_UART3
#endif

	while (!cliQuit)
	{
		memset(cInputString, 0, cmdMAX_INPUT_SIZE);
		uart_ret = read(UART_PORT, cInputString, cmdMAX_INPUT_SIZE);
		if (uart_ret == 0)
		{
			continue;
		}

		if (uart_ret)
		{
			for (i = 0; i < uart_ret; i++)
			{
				cmdbuf[readPos] = cInputString[i];
				readPos++;
				if (cInputString[i] == '\0')
				{
					printf("input: %s\r\n", cmdbuf);
					readPos = 0;
					goto procCmd;
				}
			}
			continue;
		}
	procCmd:
		do
		{
			int len;
			xReturned = FreeRTOS_CLIProcessCommand(cmdbuf, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE);

			len = strlen(pcOutputString);
			if (len > 0)
			{
				uart_ret = write(UART_PORT, pcOutputString, len);
				printf("write(%d): %s\n", uart_ret, pcOutputString);
			}
		} while (xReturned != pdFALSE);
	}
#else
	while (!cliQuit)
	{
  #ifdef CFG_CLI_USB_ACM

	  int ret;

    while (ioctl(ITP_DEVICE_USBDACM, ITP_IOCTL_IS_CONNECTED, NULL) == 0)
    {
        printf(".");
        sleep(1);
    }
    printf("\n");

    ret = read(ITP_DEVICE_USBDACM, cInputString, cmdMAX_INPUT_SIZE);
    if (ret == 0)
    {
      LOG_DBG "read null\n" LOG_END
      continue;
    }
    LOG_DBG "read(%d) %s\n", ret, cInputString  LOG_END

  	do
  	{
  	  int len;

  		/* Get the string to write to the USB ACM from the command
  		interpreter. */
  		xReturned = FreeRTOS_CLIProcessCommand( cInputString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );

  		/* Write the generated string to the USB ACM. */
  		len = strlen(pcOutputString);
  		if (len > 0)
  		{
        ret = write(ITP_DEVICE_USBDACM, pcOutputString, len);
        LOG_DBG "write(%d) %s", ret, pcOutputString  LOG_END
  		}

  	} while( xReturned != pdFALSE );

		/* All the strings generated by the input command have been sent.
		Clear the input	string ready to receive the next command. */
		memset( cInputString, 0x00, cmdMAX_INPUT_SIZE );

  #else
		/* Only interested in reading one character at a time. */
		cRxedChar = getchar();

		if ( cRxedChar == EOF )
		{
		    usleep(33000);
		}
		else if( cRxedChar == '\n' )
		{

			/* Start to transmit a line separator, just to make the output
			easier to read. */
			puts("");

			/* Pass the received command to the command interpreter.  The
			command interpreter is called repeatedly until it returns
			pdFALSE as it might generate more than one string. */
			do
			{

				/* Get the string to write to the UART from the command
				interpreter. */
				xReturned = FreeRTOS_CLIProcessCommand( cInputString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );

				/* Write the generated string to the UART. */
				puts(pcOutputString);

			} while( xReturned != pdFALSE );

			/* All the strings generated by the input command have been sent.
			Clear the input	string ready to receive the next command. */
			cInputIndex = 0;
			memset( cInputString, 0x00, cmdMAX_INPUT_SIZE );

			/* Start to transmit a line separator, just to make the output
			easier to read. */
			printf("\r\n>");
		}
		else
		{
			if( cRxedChar == '\r' )
			{
				/* Ignore the character. */
			}
			else if( cRxedChar == '\b' )
			{
				/* Backspace was pressed.  Erase the last character in the
				string - if any. */
				if( cInputIndex > 0 )
				{
					cInputIndex--;
					cInputString[ cInputIndex ] = '\0';
				}
			}
			else
			{
				/* A character was entered.  Add it to the string
				entered so far.  When a \n is entered the complete
				string will be passed to the command interpreter. */
				if( cInputIndex < cmdMAX_INPUT_SIZE )
				{
					cInputString[ cInputIndex ] = cRxedChar;
					cInputIndex++;
				}
			}
		}
  #endif // CFG_CLI_USB_ACM
	}
#endif
	cliInited = false;
  return NULL;
}

void cliDiskInit(void);
void cliFileInit(void);
void cliRawDataInit(void);
void cliStatsInit(void);
void cliSystemInit(void);
void cliUpgradeInit(void);
void cliUartUpgradeInit(void);

void cliInit(void)
{
    pthread_t task;
    pthread_attr_t attr;

    if (cliInited)
      return;

    cliQuit = false;

#if defined(CFG_FS_FAT)
    cliDiskInit();
    cliFileInit();
#endif

#if defined(CFG_CLI_USB_ACM) && (defined(CFG_SD0_STATIC) || defined(CFG_SD1_STATIC) || defined(CFG_NAND_ENABLE) || defined(CFG_NOR_ENABLE))
    cliRawDataInit();
#endif

#if defined(CFG_OPENRTOS_USE_TRACE_FACILITY) && defined(CFG_OPENRTOS_GENERATE_RUN_TIME_STATS)
    cliStatsInit();
#endif

    cliSystemInit();

#ifdef CFG_CLI_UPGRADE
    cliUpgradeInit();
#endif
#ifdef CFG_ENABLE_UART_CLI
	cliUartUpgradeInit();
#endif

    // create command line interface task
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    pthread_attr_setstacksize(&attr, CLI_STACK_SIZE);
    pthread_create(&task, NULL, CliTask, NULL);

    cliInited = true;
}

void cliExit(void)
{
  cliQuit = true;
}
